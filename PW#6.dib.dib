#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №6. Изучение производительности потоко-безопасных очередей.

**Цель:** Определить лучшую потоко-безопасную коллекцию для выполнения интенсивной обработки входящих сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Назвать оптимальную коллекцию для обработки большого количества сообщений.
2. Изучите примтив синхронизации Условная переманная.


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Условные переменные Глава 5 п.5.1. книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования
3. [Одна из реализаций условных переменных на .Net](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.manualresetevent?view=net-8.0)

## Задание.
Исслдеовать производительность BlockingCollection и ConcurrentQueue в сравнении с непотокоабезопасной очередью.

Для каждой потоко-безопасной очереди необходимо реализовать 2 потока: один записывает объект в очередь, а другой - читает объект из очереди.
Для непотокобезопасной очереди реализовать два цикла - записи миллиона объектов в очередь и чтение миллиона объектов из очереди.

Необходимо определить два промежутка времени:
- время за которое поток или цикл обработает миллион объектов
- время, необходимое на запись и чтение миллиона объектов из очреди.

Сделать десять замеров по каждой коллекции. Все замеры показать на графике.

Записать в ноутбуке вывод - какая и потоко-безопасных коллекций эффективнее. И выразить в процентах - скорость самой быстрой поток-безопасной коллекции по сравнению с обычной очредью.

**Указание**.
1. Необходимо исключить из замеров время, необходимое для запуска и остановки потоков, то есть посчитать чистое время, необходимое для обработки объектов.
Для этого следует использовать условные события, которые позволят убедиться, что оба потока запустились и готовы читать и писать объекты и только потом запускать таймер.
2. Для итогового вывода сравнивать усредненные значения.

#!markdown

## Вычисление BlockingCollection

#!csharp

using System.Threading;
using System.Collections.Concurrent;
using System.Diagnostics;

BlockingCollection<int> blockingCollection = new BlockingCollection<int>();

ManualResetEvent WriterStarted = new ManualResetEvent(false);
ManualResetEvent ReaderFinished = new ManualResetEvent(false);

private (long TotalTime, long WriteTime, long ReadTime) CalculateBlCol()
{
    Stopwatch blockingCollectionTimer = new Stopwatch();
    long writeTime = 0;
    long readTime = 0;
    Thread thread1 = new Thread(() => writeTime = WriteDataBlCol());
    Thread thread2 = new Thread(() => readTime = ReadDataBlCol());

    thread2.Start();                        // Запускаем поток чтения
    thread1.Start();                        // Запускаем поток записи

    WriterStarted.WaitOne();                // Ждём начала записи объектов в очередь
    blockingCollectionTimer.Start();        // Активируем таймер после запуска обоих потоков и начала записи
    ReaderFinished.WaitOne();               // Ожидаем, когда поток чтения всё прочитает (ждём сигнал, о том, что будет прочитан последний объект)
    blockingCollectionTimer.Stop();         // Останавливаем таймер после завершения чтения последнего объекта

    thread1.Join();
    thread2.Join();

    WriterStarted = new ManualResetEvent(false);    // Сбрасываем сигналы после завершения записи и чтения
    ReaderFinished = new ManualResetEvent(false);

    return (blockingCollectionTimer.ElapsedMilliseconds, writeTime, readTime);
}

int numObject = 1000000;

private long WriteDataBlCol()
{
    Stopwatch writeTimer = new Stopwatch();
    int countWrittenNumbers = 0;
    
    while (countWrittenNumbers < numObject)
    {
        blockingCollection.Add(1);
        countWrittenNumbers++;
        if (countWrittenNumbers == 1)
        {
            WriterStarted.Set();    // Сигнализируем о первой записи
            writeTimer.Start();
        }   
    }

    writeTimer.Stop();  // Останавливаем таймер записи после записи всех объектов
    return writeTimer.ElapsedMilliseconds;
}

private long ReadDataBlCol()
{
    Stopwatch readTimer = new Stopwatch();
    int countReadNumbers = 0;
    

    while (countReadNumbers < numObject)
    {
        if (blockingCollection.TryTake(out int item))
        {
            countReadNumbers++;
            if (countReadNumbers == 1)  // При первом чтении объекта запускаем таймер потока чтения
                readTimer.Start();
        }
    }
    
    readTimer.Stop();
    ReaderFinished.Set();       // Сигнализируем о том, что был прочитан последний объект
    return readTimer.ElapsedMilliseconds;
}

#!csharp

//#r "nuget:ScottPlot, 5.0.*"

using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);


List<int> dataX = new List<int>();
List<long> dataY1 = new List<long>();
List<long> dataY2 = new List<long>();
double avgFirstIntervalBlockCol = 0;

for (int i = 1; i < 11; i++)
{
    result = CalculateBlCol();
    firstInterval = result.ReadTime;                // Время за которое поток или цикл обработает миллион объектов
    secondInterval = result.TotalTime;              // Время, необходимое на запись и чтение миллиона объектов из очереди
    avgFirstIntervalBlockCol += firstInterval / 10.0;
    
    dataX.Add(i);
    dataY1.Add(firstInterval);
    dataY2.Add(secondInterval);
}

Console.WriteLine($"Среднее время за которое поток или цикл обработает миллион объектов: {Math.Round(avgFirstIntervalBlockCol, 2)}");

ScottPlot.Plot plt1 = new();
ScottPlot.Plot plt2 = new();
plt1.Add.Scatter(dataX, dataY1);
plt2.Add.Scatter(dataX, dataY2);

plt1.XLabel("Номер замера");
plt1.YLabel("Первый промежуток времени");
plt2.XLabel("Номер замера");
plt2.YLabel("Второй промежуток времени");

plt1.Display();
plt2.Display();

#!markdown

## Вычисление ConcurrentQueue

#!csharp

ConcurrentQueue<int> concurrentQueue = new ConcurrentQueue<int>();

WriterStarted = new ManualResetEvent(false);
ReaderFinished = new ManualResetEvent(false);

private (long TotalTime, long WriteTime, long ReadTime) CalculateConQ()
{
    Stopwatch concurrentQueueTimer = new Stopwatch();
    long writeTime = 0;
    long readTime = 0;
    Thread thread1 = new Thread(() => writeTime = WriteDataConQ());
    Thread thread2 = new Thread(() => readTime = ReadDataConQ());

    thread2.Start();            // Запускаем поток чтения
    thread1.Start();            // Запускаем поток записи

    WriterStarted.WaitOne();          // Ждём начала записи объектов в очередь
    concurrentQueueTimer.Start();     // Активируем таймер после запуска обоих потоков и начала записи
    ReaderFinished.WaitOne();         // Ожидаем, когда поток чтения всё прочитает (ждём сигнал, о том, что будет прочитан последний объект)
    concurrentQueueTimer.Stop();      // Останавливаем таймер после завершения чтения последнего объекта

    thread1.Join();
    thread2.Join();

    WriterStarted = new ManualResetEvent(false);    // Сбрасываем сигналы после завершения записи и чтения
    ReaderFinished = new ManualResetEvent(false);
    
    return (concurrentQueueTimer.ElapsedMilliseconds, writeTime, readTime);
}

int numObject = 1000000;

private long WriteDataConQ()
{
    Stopwatch writeTimer = new Stopwatch();
    int countWrittenNumbers = 0;
    
    while (countWrittenNumbers < numObject)
    {
        concurrentQueue.Enqueue(1);
        countWrittenNumbers++;
        if (countWrittenNumbers == 1)
        {
            WriterStarted.Set();    // Сигнализируем о первой записи
            writeTimer.Start();
        }
    }

    writeTimer.Stop();  // Останавливаем таймер записи после записи всех объектов
    return writeTimer.ElapsedMilliseconds;
}

private long ReadDataConQ()
{
    Stopwatch readTimer = new Stopwatch();
    int countReadNumbers = 0;
    

    while (countReadNumbers < numObject)
    {
        if (concurrentQueue.TryDequeue(out int item))
        {
            countReadNumbers++;
            if (countReadNumbers == 1)  // При первом чтении объекта запускаем таймер потока чтения
                readTimer.Start();
        }
    }
    
    readTimer.Stop();
    ReaderFinished.Set();       // Сигнализируем о том, что был прочитан последний объект
    return readTimer.ElapsedMilliseconds;
}

#!csharp

using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);


List<int> dataX = new List<int>();
List<long> dataY1 = new List<long>();
List<long> dataY2 = new List<long>();
double avgFirstIntervalConQ = 0;

for (int i = 1; i < 11; i++)
{
    result = CalculateConQ();
    firstInterval = result.ReadTime;
    secondInterval = result.TotalTime;
    avgFirstIntervalConQ += firstInterval / 10.0;
    
    dataX.Add(i);
    dataY1.Add(firstInterval);
    dataY2.Add(secondInterval);
}

Console.WriteLine($"Среднее время за которое поток или цикл обработает миллион объектов: {Math.Round(avgFirstIntervalConQ, 2)}");

ScottPlot.Plot plt1 = new();
ScottPlot.Plot plt2 = new();
plt1.Add.Scatter(dataX, dataY1);
plt2.Add.Scatter(dataX, dataY2);

plt1.XLabel("Номер замера");
plt1.YLabel("Первый промежуток времени");
plt2.XLabel("Номер замера");
plt2.YLabel("Второй промежуток времени");

plt1.Display();
plt2.Display();

#!markdown

## Вычисление Queue

#!csharp

private (long TotalTime, long WriteTime, long ReadTime) CalculateQueue(int numObject)
{
    Queue<int> queue = new Queue<int>();
    Stopwatch stopwatch = new Stopwatch();
    Stopwatch totalTime = new Stopwatch();
    int countWritten = 0;

    stopwatch.Start();
    totalTime.Start();
    while (countWritten < numObject)
    {
        queue.Enqueue(1);
        countWritten++;
    }
    totalTime.Stop();
    stopwatch.Stop();
    long writeTime = stopwatch.ElapsedMilliseconds;
    stopwatch.Reset();

    int countRead = 0;
    stopwatch.Start();
    totalTime.Start();
    while (countRead < numObject)
    {
        queue.Dequeue();
        countRead++;
    }
    totalTime.Stop();
    stopwatch.Stop();
    long readTime = stopwatch.ElapsedMilliseconds;

    return (totalTime.ElapsedMilliseconds, writeTime, readTime);
}

var result = CalculateQueue(1000000);
long firstInterval = result.ReadTime + result.WriteTime;
long secondInterval = result.TotalTime;
Console.WriteLine($"Время, за которое поток обработает миллион объектов: {firstInterval} ms");
Console.WriteLine($"Время, необходимое на запись и чтение миллиона объектов: {secondInterval} ms");

#!csharp

List<int> dataX = new List<int>();
List<long> dataY1 = new List<long>();
List<long> dataY2 = new List<long>();
double avgFirstIntervalQueue = 0;

for (int i = 1; i < 11; i++)
{
    result = CalculateQueue(1000000);
    firstInterval = result.ReadTime + result.WriteTime;
    secondInterval = result.TotalTime;
    avgFirstIntervalQueue += firstInterval / 10.0;
    
    dataX.Add(i);
    dataY1.Add(firstInterval);
    dataY2.Add(secondInterval);
}

Console.WriteLine($"Среднее время за которое поток или цикл обработает миллион объектов: {Math.Round(avgFirstIntervalQueue, 2)}");

ScottPlot.Plot plt1 = new();
ScottPlot.Plot plt2 = new();
plt1.Add.Scatter(dataX, dataY1);
plt2.Add.Scatter(dataX, dataY2);

plt1.XLabel("Номер замера");
plt1.YLabel("Первый промежуток времени");
plt2.XLabel("Номер замера");
plt2.YLabel("Второй промежуток времени");

plt1.Display();
plt2.Display();

#!markdown

## Вывод
