#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №6. Изучение производительности потоко-безопасных очередей.

**Цель:** Определить лучшую потоко-безопасную коллекцию для выполнения интенсивной обработки входящих сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Назвать оптимальную коллекцию для обработки большого количества сообщений.
2. Изучите примтив синхронизации Условная переманная.


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Условные переменные Глава 5 п.5.1. книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования
3. [Одна из реализаций условных переменных на .Net](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.manualresetevent?view=net-8.0)

## Задание.
Исслдеовать производительность BlockingCollection и ConcurrentQueue в сравнении с непотокоабезопасной очередью.

Для каждой потоко-безопасной очереди необходимо реализовать 2 потока: один записывает объект в очередь, а другой - читает объект из очереди.
Для непотокобезопасной очереди реализовать два цикла - записи миллиона объектов в очередь и чтение миллиона объектов из очереди.

Необходимо определить два промежутка времени:
- время за которое поток или цикл обработает миллион объектов
- время, необходимое на запись и чтение миллиона объектов из очреди.

Сделать десять замеров по каждой коллекции. Все замеры показать на графике.

Записать в ноутбуке вывод - какая и потоко-безопасных коллекций эффективнее. И выразить в процентах - скорость самой быстрой поток-безопасной коллекции по сравнению с обычной очредью.

**Указание**.
1. Необходимо исключить из замеров время, необходимое для запуска и остановки потоков, то есть посчитать чистое время, необходимое для обработки объектов.
Для этого следует использовать условные события, которые позволят убедиться, что оба потока запустились и готовы читать и писать объекты и только потом запускать таймер.
2. Для итогового вывода сравнивать усредненные значения.

#!markdown

## Вычисление BlockingCollection

#!csharp

using System.Threading;
using System.Collections.Concurrent;
using System.Diagnostics;

BlockingCollection<int> blockingCollection = new BlockingCollection<int>();

private void CalculateBlCol()
{
    Thread thread1 = new Thread(() => ReadDataBlCol(1000000));
    Thread thread2 = new Thread(() => WriteDataBlCol(1000000));

    thread1.Start();
    thread2.Start();

    thread1.Join();
    thread2.Join();
}

private void ReadDataBlCol(int numObject)
{
    Stopwatch stw = new Stopwatch();
    Thread curThread = Thread.CurrentThread;

    int countReadNumbers = 0;
    if (curThread.ThreadState == System.Threading.ThreadState.Running) stw.Start();

    while (countReadNumbers < numObject)
    {
        blockingCollection.Take();
        countReadNumbers++;
    }

    stw.Stop();
    Console.WriteLine($"Время, необходимое на чтение: {stw.ElapsedMilliseconds}");
}

private void WriteDataBlCol(int numObject)
{
    Stopwatch stw = new Stopwatch();
    Thread curThread = Thread.CurrentThread;
    
    int countWrittenNumbers = 0;
    if (curThread.ThreadState == System.Threading.ThreadState.Running) stw.Start();
    
    while (countWrittenNumbers < numObject)
    {
        blockingCollection.Add(1);
        countWrittenNumbers++;
    }

    stw.Stop();
    Console.WriteLine($"Время, необходимое на запись: {stw.ElapsedMilliseconds}");
}

Stopwatch sw = new Stopwatch();

sw.Start();
CalculateBlCol();
sw.Stop();
Console.WriteLine($"Время вычислений с BlockingCollection: {sw.ElapsedMilliseconds} ms");
sw.Reset();

#!markdown

## Вычисление ConcurrentQueue

#!csharp

ConcurrentQueue<int> concurrentQueue = new ConcurrentQueue<int>();

ManualResetEvent WriterFinished = new ManualResetEvent(false);
ManualResetEvent ReaderFinished = new ManualResetEvent(false);

private void CalculateConQ()
{
    Stopwatch concurrentQueueTimer = new Stopwatch();
    Thread thread1 = new Thread(WriteDataConQ);
    Thread thread2 = new Thread(ReadDataConQ);

    thread1.Start();
    thread2.Start();

    concurrentQueueTimer.Start();     // Активируем таймер после запуска обоих потоков
    WriterFinished.WaitOne();
    ReaderFinished.WaitOne();
    concurrentQueueTimer.Stop();      // Останавливаем таймер после завершения работы обоих потоков

    Console.WriteLine($"Время вычислений с ConcurrentQueue: {concurrentQueueTimer.ElapsedMilliseconds} ms");
}

int numObject = 1000000;

private void WriteDataConQ()
{
    Stopwatch writeTimer = new Stopwatch();
    int countWrittenNumbers = 0;
    writeTimer.Start();

    while (countWrittenNumbers < numObject)
    {
        concurrentQueue.Enqueue(1);
        countWrittenNumbers++;
    }

    WriterFinished.Set();       // Сигнализируем о том, что завершилась работа с очередью (без учёта времени на остановку потока)
    writeTimer.Stop();
    Console.WriteLine($"Время, необходимое на запись: {writeTimer.ElapsedMilliseconds}");
}

private void ReadDataConQ()
{
    Stopwatch readTimer = new Stopwatch();
    int countReadNumbers = 0;
    readTimer.Start();

    while (countReadNumbers < numObject)
    {
        if (concurrentQueue.TryPeek(out int item))
            countReadNumbers++;
    }
    
    ReaderFinished.Set();       // Сигнализируем о том, что завершилась работа с очередью (без учёта времени на остановку потока)
    readTimer.Stop();
    Console.WriteLine($"Время, необходимое на чтение: {readTimer.ElapsedMilliseconds}");
}

CalculateConQ();

#!csharp

private void CalculateQueue(int numObject)
{
    Queue<int> queue = new Queue<int>();
    Stopwatch stw = new Stopwatch();

    int countWritten = 0;
    stw.Start();

    while (countWritten < numObject)
    {
        queue.Enqueue(1);
        countWritten++;
    }
    Console.WriteLine($"Время, необходимаое на запись: {stw.ElapsedMilliseconds}");
    
    stw.Reset();

    int countRead = 0;
    stw.Start();
    
    while (countRead < numObject)
    {
        queue.Peek();
        countRead++;
    }
    stw.Stop();
    Console.WriteLine($"Время, необходимое на чтение: {stw.ElapsedMilliseconds}");
}

sw.Start();
CalculateQueue(1000000);
sw.Stop();
Console.WriteLine($"Время вычислений с Queue: {sw.ElapsedMilliseconds} ms");
sw.Reset();

#!markdown

## Вывод
