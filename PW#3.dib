#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!markdown

Код, реализующий многопоточное вычисление

#!csharp

using System.Threading;

class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    static double square;
    static Barrier barrier;
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        square = 0;
        barrier = new Barrier(threadsnumber);
        List<Thread> threads = new List<Thread>();
        for (int i = 0; i < threadsnumber; i++)
        {
            double start = a+i*(b-a)/threadsnumber;
            double end = a+(i+1)*(b-a)/threadsnumber;
            threads.Add(new Thread(() => ThreadCalculations(start, end, function, step)));
        }

        foreach (Thread thread in threads) thread.Start();
        foreach (Thread thread in threads) thread.Join();
        return square;
    }

    public static void ThreadCalculations(double a, double b, Func<double, double> function, double step)
    {
        int numSteps = (int)((b-a)/step);

        double ThreadSquare = 
            (from i in Enumerable.Range(0, numSteps)
            select ((function(a + i*step) + function(a + i*step + step)) / 2) * step).Sum();

        if (numSteps * step < b - a)
        {
            double x1 = a + numSteps*step;
            ThreadSquare += ((function(x1) + function(b)) / 2) * (b - x1);
        }

        Interlocked.CompareExchange(ref square, square+ThreadSquare, square);
        barrier.SignalAndWait();
    }
}

#!markdown

Код, реализующий однопоточное вычисление

#!csharp

class TrapezoidalRule
{
    public static double Solve(Func<double, double> f, double a, double b, double dx)
    {
        double epsilon = 1e-7;

        if (dx <= epsilon || Math.Abs(b-a) <= epsilon || !Double.IsNormal(b) || !Double.IsNormal(a) || b < a) throw new ArgumentException();
        double square = 0;

        int n = (int)((b-a)/dx);
        
        IEnumerable<double> squaresQuery = 
            from i in Enumerable.Range(0, n)
            select ((f(a + i*dx) + f(a + i*dx + dx)) / 2) * dx;

        square = squaresQuery.Sum();

        if (n * dx < b - a)
        {
            double x1 = a + n*dx;
            square += ((f(x1) + f(b)) / 2) * (b - x1);
        }
        return square;
    }
}

#!markdown

Определение минимального шага(1e-1, 1e-2, 1 e-3, 1e-4, 1e-5, 1e-6), обеспечивающего оптимальную производительность с точностью 1e-4

#!csharp

using System.Diagnostics;

var SIN = (double x) => Math.Sin(x);
double result = DefiniteIntegral.Solve(-100, 100, SIN, 1e-3, 15);
double rightAnswer = 0;
if (Math.Abs(result - rightAnswer) <= 1e-4) Console.WriteLine("Заданная точность 1e-4 обеспечивается шагом 1e-5.");

Stopwatch sw = new Stopwatch();

sw.Start();
TrapezoidalRule.Solve(SIN, -100, 100, 1e-4);
sw.Stop();
Console.WriteLine($"Время с шагом 1e-4: {sw.ElapsedMilliseconds/1000.0:F2} (сек)");
sw.Reset();

sw.Start();
TrapezoidalRule.Solve(SIN, -100, 100, 1e-5);
sw.Stop();
Console.WriteLine($"Время с шагом 1e-5: {sw.ElapsedMilliseconds/1000.0:F2} (сек)");
sw.Reset();

sw.Start();
TrapezoidalRule.Solve(SIN, -100, 100, 1e-6);
sw.Stop();
Console.WriteLine($"Время с шагом 1e-6: {sw.ElapsedMilliseconds/1000.0:F2} (сек)");
/*
    Видим, что для вычислений с шагом 1e-6 требуется значительно больше времени, чем для шага 1e-5. Это время многократно увеличится, если считать среднее значение,
так как мы будем многократно запускать рассчёт (~5 секунд * количество запусков) Уже даже с 3 запусками придётся ждать целых 15 секунд. Однако, если мы возьмём шаг
1e-5, то время, которое придётся нам ждать будет незначительным, даже при 10 запусках (около 5 секунд). Ну и так как этот шаг меньше чем 1e-4, при том условии, что
что производительность оптимальна, и нам не придётся ждать очень долго при вычислении среднего значения, выберем именно этот шаг 1e-5.
*/

#!markdown

Графическое представление зависимости времени выполнения программы от числа потоков

#!csharp

#r "nuget:ScottPlot, 5.0.*"

using ScottPlot;
using System.Diagnostics;
using Microsoft.DotNet.Interactive.Formatting;

Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);

var SIN = (double x) => Math.Sin(x);

List<double> dataTime = new List<double>();
List<int> dataThreads = new List<int>();


// Измерение среднего веремени, которое требуется для каждого числа потоков
Stopwatch stopwatch = new Stopwatch();
for (int threadsNumber = 2; threadsNumber < 33; threadsNumber += 2)
{
    // Для каждого числа потоков время измеряется 4 раза
    int numberOfMeasurements = 4;
    stopwatch.Start();
    for (int i = 0; i < numberOfMeasurements; i++)
    {
        DefiniteIntegral.Solve(-100, 100, SIN, 1e-5, threadsNumber);
    }
    stopwatch.Stop();
    dataTime.Add(stopwatch.ElapsedMilliseconds/numberOfMeasurements);
    dataThreads.Add(threadsNumber);
    stopwatch.Reset();
}

// Определение потока с минимальным временем
var minThread = dataTime
    .Zip(dataThreads, (time, thread) => new { Time = time, Thread = thread })
    .OrderBy(pair => pair.Time)
    .First();

Console.WriteLine($"Число потоков, обеспечивающее самое быстрое решение: {minThread.Thread}. Время(мс): {minThread.Time}");

ScottPlot.Plot plt = new();
plt.Add.Scatter(dataTime, dataThreads);

plt

#!markdown

На графике показана зависимость времени выполнения от числа потоков

#!markdown

Сравнение результатов однопоточного вычисления с многопоточным

#!csharp

using System.Diagnostics;

Stopwatch singleThread = new Stopwatch();
Stopwatch multiThread = new Stopwatch();

var SIN = (double x) => Math.Sin(x);
int numberOfMeasurements = 10; 

singleThread.Start();
for (int i = 0; i < numberOfMeasurements; i++)
    TrapezoidalRule.Solve(SIN, -100, 100, 1e-5);
singleThread.Stop();

multiThread.Start();
for (int i = 0; i < numberOfMeasurements; i++)
    DefiniteIntegral.Solve(-100, 100, SIN, 1e-5, minThread.Thread);
multiThread.Stop();

long avgSingleThread = singleThread.ElapsedMilliseconds/numberOfMeasurements;
long avgMultiThread = multiThread.ElapsedMilliseconds/numberOfMeasurements;


Console.WriteLine($"Время с одним потоком: {avgSingleThread} мс\nВремя с несколькими потоками: {avgMultiThread} мс");

// Вычисление прироста скорости
Console.WriteLine($"Прирост времени при однопоточном вычислении {(avgSingleThread - avgMultiThread)/(double)avgMultiThread*100:F2}%");

#!markdown

# Summary
1. Размер шага был выбран 1e-5. Для вычислений с шагом 1e-6 требуется значительно больше времени, чем для шага 1e-5. Это время многократно увеличится, если считать среднее значение,
так как мы будем многократно запускать рассчёт (~5 секунд * количество запусков) Уже даже с 3 запусками придётся ждать целых ~15 секунд. Однако, если мы возьмём шаг
1e-5, то время, которое придётся нам ждать будет незначительным, даже при 10 запусках (около 5 секунд). Также этот шаг меньше чем 1e-4, а нам требуется выбрать минмальный шаг. При том условии,
что производительность оптимальна, и нам не придётся ждать очень долго при вычислении среднего значения, выберем именно этот шаг 1e-5.

2. Количество потоков, с которыми вычисления производятся наиболее быстро: 12-16, 28-32. Именно эти значения чаще всего(если несколько раз запускать) определяются в части с графическим представлением зависимости времени от потоков. Однако при 28-32 потоках время выполнения незначительно отличается от 12-16 потоков, поэтому нет смысла от числа потоков, большего чем 16. И оптимальным является 12-16 потоков.

3. Время с одним потоком: ~520 мс. Время с несколькими потоками: ~75 мс. Прирост времени при однопоточном вычислении ~580% (Вычисление представлено в коде выше)

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8), 1e-4);

Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);
