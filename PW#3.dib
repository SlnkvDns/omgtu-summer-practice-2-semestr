#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!markdown

Код, реализующий многопоточное вычисление

#!csharp

using System.Threading;

class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    static double square;
    static Barrier barrier;
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        square = 0;
        barrier = new Barrier(threadsnumber);
        List<Thread> threads = new List<Thread>();
        for (int i = 0; i < threadsnumber; i++)
        {
            double start = a+i*(b-a)/threadsnumber;
            double end = a+(i+1)*(b-a)/threadsnumber;
            threads.Add(new Thread(() => ThreadCalculations(start, end, function, step)));
        }

        foreach (Thread thread in threads) thread.Start();
        foreach (Thread thread in threads) thread.Join();
        return square;
    }

    public static void ThreadCalculations(double a, double b, Func<double, double> function, double step)
    {
        int numSteps = (int)((b-a)/step);

        double ThreadSquare = 
            (from i in Enumerable.Range(0, numSteps)
            select ((function(a + i*step) + function(a + i*step + step)) / 2) * step).Sum();

        if (numSteps * step < b - a)
        {
            double x1 = a + numSteps*step;
            ThreadSquare += ((function(x1) + function(b)) / 2) * (b - x1);
        }

        Interlocked.CompareExchange(ref square, square+ThreadSquare, square);
        barrier.SignalAndWait();
    }
}

#!markdown

Код, реализующий однопоточное вычисление

#!csharp

class TrapezoidalRule
{
    public static double Solve(Func<double, double> f, double a, double b, double dx)
    {
        double epsilon = 1e-7;

        if (dx <= epsilon || Math.Abs(b-a) <= epsilon || !Double.IsNormal(b) || !Double.IsNormal(a) || b < a) throw new ArgumentException();
        double square = 0;

        int n = (int)((b-a)/dx);
        

        // Синтаксис запросов
        IEnumerable<double> squaresQuery = 
            from i in Enumerable.Range(0, n)
            select ((f(a + i*dx) + f(a + i*dx + dx)) / 2) * dx;

        square = squaresQuery.Sum();

        if (n * dx < b - a)
        {
            double x1 = a + n*dx;
            square += ((f(x1) + f(b)) / 2) * (b - x1);
        }
        return square;
    }
}

#!markdown

Измерения вычислений

#!csharp

using System.Diagnostics;

Stopwatch oneThread = new Stopwatch();
Stopwatch multiThread = new Stopwatch();

var SIN = (double x) => Math.Sin(x);

oneThread.Start();
double result1 = TrapezoidalRule.Solve(SIN, -100, 100, 1e-1);
oneThread.Stop();

multiThread.Start();
double result2 = DefiniteIntegral.Solve(-100, 100, SIN, 1e-1, 1);
multiThread.Stop();

Console.WriteLine($"Время с одним потоком: {oneThread.ElapsedMilliseconds}\nВремя с несколькими потоками: {multiThread.ElapsedMilliseconds}");
Console.WriteLine(Math.Abs(result2) <= 1e-4);

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8), 1e-4);

Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);
