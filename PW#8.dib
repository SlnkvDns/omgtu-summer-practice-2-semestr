#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №8. Реализация планировщика команд.

**Цель:** Реализация длительных операций.

**Результаты:** После выполнения работы Вы сможете:
1. Сделать возможным в потоке выполнять длительные операции.

## Задание.
Пусть, в условиях практической работы №7, у нас есть поток с очередью, который в цикле извлекает команды из очереди и выполняет их.

Некоторые из команд не могут выполнить всю работу за один вызов метода Execute без блокирования на длительное время выполнения всех остальных командд из очереди.

Например, если какая-нибудь сетевая игра представлена командой, то пока одна игра не закончится, следующая не начнется. Чтобы эффективнее использовать процессорные
можности, нужно обеспечить возхможность поиграть как можно большему количеству игроков.

Для этого используют режим псевдопараллельной обработки. Когда все время работы разбивают на небольшие отрезки, каждый из которых выполняется
за один вызов метода Execute. Чтобы выполнить всю работу, нужно вызвать метод Execute несколько раз, до тех пор пока работа не будет завершена.
Это позволяет между вызовами Execute одного экземплыра команды вызывать метод Execute других команд.

Так устроен, например, ренедринг страницы в браузере. Только в браузеоре это используется не для рендеренга всех вкладок, а для обработки 
реакций пользователя на странице.

В прошлой работе все команды, которые выполнялись в потоке, брались из очереди. Поэтому первая идея - это положить долгоиграющую операцию обратно в очередь.
Но это может привести к состоянию мертвой блокировки потока: если очередь будет полна, то поток, который попытается сделать запись, будет заблокирован до тех пор, 
пока в очереди не появится свободное место. Поэтому нельзя в одном и том же потоке читать и писать в очередь неблокируемым образом.

Чтобы избежать мертвой блокировки потока, необходимо ввести понятие Планировщика, который будет отвечать за выбор следующей длительной задачи для выполнения,
а чтение из очереди оставить только для новых операций. 

#!csharp

using System;
using System.Threading;
using System.Collections.Concurrent;
using System.Collections.Generic;

public interface IScheduler
{
    bool HasCommand();
    ICommand Select(bool isLongThread, Thread currentServerThread);
    void Add(ICommand cmd);
}

public interface ICommand
{
    public string Name {get;}
    bool wasCalled { get; set; }
    void Execute();
}

class Scheduler : IScheduler
{
    private ConcurrentQueue<ICommand> queue = new ConcurrentQueue<ICommand>();
    private ConcurrentQueue<ICommand> longQueue = new ConcurrentQueue<ICommand>();
    private List<ServerThread> longThreads;
    private List<int> longThreadsId = new List<int>();
    private int currentLongThreadIndex;

    public Scheduler(List<ServerThread> longThreads)
    {
        this.longThreads = longThreads;
        foreach(var longThread in longThreads)
        {
            longThreadsId.Add(longThread.currentServerThread.ManagedThreadId);
        }
        currentLongThreadIndex = 0;
    }

    public bool HasCommand()
    {
        return !queue.IsEmpty || !longQueue.IsEmpty;
    }

    public ICommand Select(bool isLongThread, Thread currentServerThread)
    {
        if (isLongThread && currentServerThread.ManagedThreadId == longThreadsId[currentLongThreadIndex])
        {
            if (longQueue.TryDequeue(out ICommand command))
            {
                return command;
            }
            currentLongThreadIndex = (currentLongThreadIndex + 1) % longThreads.Count;
        }
        else
        {
            if (queue.TryDequeue(out ICommand command))
            {
                return command;
            }
        }

        return null;
    }

    public void Add(ICommand cmd)
    {
        if (cmd is LongRunningCommandWrapper)
        {
            longQueue.Enqueue(cmd);
        }
        else
        {
            queue.Enqueue(cmd);
        }
    }
}

class HardStop : ICommand
{
    ServerThread thread;
    public string Name {get;} = "HardStop";
    public bool wasCalled { get; set; }

    public HardStop(ServerThread stoppedThread)
    {
        thread = stoppedThread;
        wasCalled = false;
    }

    public void Execute()
    {
        if (Thread.CurrentThread != thread.currentServerThread)
        {
            throw new Exception();
        }

        thread.canContinue = false;
        wasCalled = true;
    }
}

class SoftStop : ICommand
{
    ServerThread thread;
    public string Name {get;} = "SoftStop";
    public bool wasCalled { get; set; }
    public SoftStop(ServerThread stoppedThread)
    {
        thread = stoppedThread;
        wasCalled = false;
    }

    public void Execute()
    {
        if (Thread.CurrentThread != thread.currentServerThread)
        {
            throw new Exception();
        }

        thread.softStopFlag = true;
        wasCalled = true;
    }
}

class SomeCommand : ICommand
{
    public bool wasCalled { get; set; }
    public string Name {get;}

    public SomeCommand(string name)
    {
        wasCalled = false;
        Name = name;
    }

    public void Execute()
    {
        wasCalled = true;
        Console.WriteLine($"Выполнение {Name} в потоке (Id): {Thread.CurrentThread.ManagedThreadId}");
    }
}

class LongRunningCommandWrapper : ICommand
{
    ICommand longCommand;
    public bool wasCalled { get; set; }
    public string Name {get;}

    public LongRunningCommandWrapper(ICommand command)
    {
        longCommand = command;
        wasCalled = false;
        Name = command.Name;
    }

    public void Execute()
    {
        longCommand.Execute();
        wasCalled = true;
    }
}

class ServerThread
{
    public Thread currentServerThread;
    public bool canContinue = true;
    public bool softStopFlag = false;
    public Scheduler scheduler;
    public bool isLongThread;

    public ServerThread(Scheduler scheduler, bool isLongThread)
    {
        this.scheduler = scheduler;
        this.isLongThread = isLongThread;
        Thread thread = new Thread(Handle);
        currentServerThread = thread;
        thread.Start();
    }

    public void AddCommand(ICommand command)
    {
        scheduler.Add(command);
    }

    private void ExeptionHandler(Exception ex, ICommand command)
    {
        if (command != null)
        {
            // Обработка исключения
        }
    }

    public void Handle()
    {
        while (canContinue)
        {
            ICommand command = null;
            try
            {
                if (scheduler.HasCommand())
                {
                    command = scheduler.Select(isLongThread, currentServerThread);
                    if (command != null)
                    {
                        command.Execute();
                    }
                }
                else if (softStopFlag)
                {
                    canContinue = false;
                }
            }
            catch (Exception ex)
            {
                ExeptionHandler(ex, command);
            }
        }
    }
}

#!csharp

ServerThread longThead1 = new ServerThread(scheduler, true);
ServerThread longThead2 = new ServerThread(scheduler, true);
List<ServerThread> longThreads = new List<ServerThread> {longThead1, longThead2};
Scheduler scheduler = new Scheduler(longThreads);
ServerThread server = new ServerThread(scheduler, false);





SomeCommand cmd1 = new SomeCommand("cmd1");
LongRunningCommandWrapper longCmd1 = new LongRunningCommandWrapper(new SomeCommand("longCmd1"));
SomeCommand cmd2 = new SomeCommand("cmd2");
SomeCommand cmd3 = new SomeCommand("cmd3");
LongRunningCommandWrapper longCmd2 = new LongRunningCommandWrapper(new SomeCommand("longCmd2"));
LongRunningCommandWrapper longCmd3 = new LongRunningCommandWrapper(new SomeCommand("longCmd3"));
LongRunningCommandWrapper longCmd4 = new LongRunningCommandWrapper(new SomeCommand("longCmd4"));
LongRunningCommandWrapper longCmd5 = new LongRunningCommandWrapper(new SomeCommand("longCmd5"));
SomeCommand cmd4 = new SomeCommand("cmd4");



server.AddCommand(cmd1);
server.AddCommand(cmd2);  // Команда с длительным выполнением
server.AddCommand(longCmd1);
server.AddCommand(cmd3);
server.AddCommand(longCmd2);
server.AddCommand(longCmd3);
server.AddCommand(longCmd4);
server.AddCommand(cmd4);
server.AddCommand(longCmd5);


Thread.Sleep(100);

#!markdown

Необходимо реализовать поток, который способен реализоввывать длительные операции.

**Указание.** 
1. В практической работе №7 из очереди команды извлекались блокируеммым образом с помощью метода Take(), при наличии планировщика так делать нельзя: поток
может заснуть несмотря на наличие команд в планировщике до тех пор, пока не будет записана новая команда в очередь.

С другой стороны, если будем всегда читать неблокируемым образом, а в планировщике нет никакой работы, то будем тратить процессорное время без полезной нагрузки.

Необходимо учесть этот момент при реализации очереди.

2. Для обепечения справедливости стратегии планировщика в слабом смысле использовать стратегию Round Robbin (циклическую) для определения следующего потока на исполнение.
